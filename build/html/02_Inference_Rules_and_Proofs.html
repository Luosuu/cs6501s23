<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3. Inference/Deduction/Proofs &mdash; A Predicate Logic 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="2. Functions and Applications" href="01_Functions_and_Applications.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> A Predicate Logic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="00_Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="01_Functions_and_Applications.html">2. Functions and Applications</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Inference/Deduction/Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">3.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implication">3.2. Implication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conjunction">3.3. Conjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disjunction">3.4. Disjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#biimplication">3.5. Biimplication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generalization">3.6. Generalization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#true-and-false">3.7. True and False</a></li>
<li class="toctree-l2"><a class="reference internal" href="#negation">3.8. Negation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#proof-by-negation">3.8.1. Proof by Negation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proof-by-contradiction">3.8.2. Proof by Contradiction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#predicates">3.9. Predicates</a></li>
<li class="toctree-l2"><a class="reference internal" href="#existence">3.10. Existence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fallacies">3.11. Fallacies</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">A Predicate Logic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">3. </span>Inference/Deduction/Proofs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/02_Inference_Rules_and_Proofs.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="inference-deduction-proofs">
<span id="introduction"></span><h1><span class="section-number">3. </span>Inference/Deduction/Proofs<a class="headerlink" href="#inference-deduction-proofs" title="Permalink to this heading">&#61633;</a></h1>
<section id="id1">
<h2><span class="section-number">3.1. </span>Introduction<a class="headerlink" href="#id1" title="Permalink to this heading">&#61633;</a></h2>
<p>As a reminder, here are the inference rules (and a few
&#8220;logical fallacies&#8221; that you tested for validity in the
setting of propositional logic.</p>
<p>In this next section of class, we &#8216;ll see that enhanced
versions of these inference rules serve as foundations
for valid reasoning about the truth of propositions in
predicate logic.</p>
<ol class="arabic simple">
<li><p>X &#8744; Y, X &#8866; &#172;Y             &#8211; affirming the disjunct</p></li>
<li><p>X, Y &#8866; X &#8743; Y              &#8211; and introduction</p></li>
<li><p>X &#8743; Y &#8866; X                 &#8211; and elimination left</p></li>
<li><p>X &#8743; Y &#8866; Y                 &#8211; and elimination right</p></li>
<li><p>&#172;&#172;X &#8866; X                   &#8211; negation elimination</p></li>
<li><p>&#172;(X &#8743; &#172;X)                 &#8211; no contradiction</p></li>
<li><p>X &#8866; X &#8744; Y                 &#8211; or introduction left</p></li>
<li><p>Y &#8866; X &#8744; Y                 &#8211; or introduction right</p></li>
<li><p>X &#8594; Y, &#172;X &#8866; &#172; Y           &#8211; denying the antecedent</p></li>
<li><p>X &#8594; Y, Y &#8594; X &#8866; X &#8596; Y      &#8211; iff introduction</p></li>
<li><p>X &#8596; Y &#8866; X &#8594; Y            &#8211; iff elimination left</p></li>
<li><p>X &#8596; Y &#8866; Y &#8594; X            &#8211; iff elimination right</p></li>
<li><p>X &#8744; Y, X &#8594; Z, Y &#8594; Z &#8866; Z  &#8211; or elimination</p></li>
<li><p>X &#8594; Y, Y &#8866; X             &#8211; affirming the conclusion</p></li>
<li><p>X &#8594; Y, X &#8866; Y             &#8211; arrow elimination</p></li>
<li><p>X &#8594; Y, Y &#8594; Z &#8866; X &#8594; Z     &#8211; transitivity of &#8594;</p></li>
<li><p>X &#8594; Y &#8866; Y &#8594; X            &#8211; converse</p></li>
<li><p>X &#8594; Y &#8866; &#172;Y &#8594; &#172;X          &#8211; contrapositive</p></li>
<li><p>&#172;(X &#8744; Y) &#8596; &#172;X &#8743; &#172;Y       &#8211; DeMorgan #1 (&#172; distributes over &#8744;)</p></li>
<li><p>&#172;(X &#8743; Y) &#8596; &#172;X &#8744; &#172;Y       &#8211; Demorgan #2 (&#172; distributes over &#8743;)</p></li>
</ol>
<p>In what follows, we present the familiar inference
rules above but now in the context of the more expressive
predicate logic of the Lean Prover tool. A big benefit
is that &#8220;Lean&#8221; checks the syntax of our expressions.</p>
<p>We&#8217;ve also added inference rules for the quantifiers, &#8704; and
&#8707;, which of course are not relevant in propositional logic
but that are essential in predicate logic (whether first- or
higher-order).</p>
</section>
<section id="implication">
<h2><span class="section-number">3.2. </span>Implication<a class="headerlink" href="#implication" title="Permalink to this heading">&#61633;</a></h2>
<p>Arrow elimination is the reduction of a function
application to an argument to obtain a result.</p>
<p>Suppose a function, f, takes an arbitrary string, s,
as an argument, and returns a natural number result.
For example, the function, string.length, takes a
string as an argument and returns a natural number
as a result, namely the number of characters in the
string.</p>
<p>We can write the type of f as string -&gt; nat, or formally,
(f : string -&gt; nat).</p>
<p>In Lean and languages like it, we write the application of
f to s as &#8220;f s&#8221;. In Python we&#8217;d write it as f(s).</p>
<p>So we can apply (f : string -&gt; nat) to a value (s : string)
and the result is a natural number (nat).</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">string.length</span>
<span class="k">#reduce</span> <span class="n">string.length</span> <span class="s2">&quot;Hello, Logic!&quot;</span>
</pre></div>
</div>
<p>Arrow elimination is function application! When we apply
a function of type (string.length : string &#8594; &#8469;) to a string
argument, as in the expression (string.length &#8220;Hello!&#8221;),
the result is a natural number. You can think of a function
as stating that &#8220;if you give me an argument of the right
type to consume, I will reduce to a value of the result
type.&#8221;</p>
<p>That&#8217;s how it works in the realm of computation. Now let&#8217;s
turn to logic.</p>
<p>Instead of the data types, string and nat, suppose P and Q
are arbitrary propositions.</p>
<p>That means that P -&gt; Q is also a propositions, &#8220;If P then Q&#8221;.</p>
<p>Now suppose that you&#8217;ve proven P -&gt; Q and that pq is a proof of it.</p>
<p>Just like we had (f : string -&gt; nat) above, now we have (pq : P -&gt; Q).</p>
<p>You  can even think of pq as a function: one that takes a proof
of P and returns a proof of Q!</p>
<p>That means that whenever P is true (with a proof, p), then (pq p)
is a proof of Q.</p>
<p>In other words, because you have (pq: P -&gt; Q) and (p : P) then (pq q)
is a proof of Q.</p>
<p>If P -&gt; Q is true and P is true then Q must be.</p>
<p>If you have a proof of P -&gt; Q and you have a proof of P you can construct
a proof of Q.</p>
<p>That&#8217;s arrow elimination.</p>
<p>Does this help?</p>
</section>
<section id="conjunction">
<h2><span class="section-number">3.3. </span>Conjunction<a class="headerlink" href="#conjunction" title="Permalink to this heading">&#61633;</a></h2>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">and_introduction</span>  <span class="o">:</span> <span class="kt">Prop</span>  <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8743;</span> <span class="n">Y</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">and_elim_left</span>     <span class="o">:</span> <span class="kt">Prop</span>  <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">X</span> <span class="bp">&#8743;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span>
<span class="kd">def</span> <span class="n">and_elim_right</span>    <span class="o">:</span> <span class="kt">Prop</span>  <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">X</span> <span class="bp">&#8743;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Y</span>
</pre></div>
</div>
<p>Note that we are able to express these rules of logic very
naturally in higher-order constructive logic because we can
quantify over propositions. You cannot write these definitions
in first-order logic because it doesn&#8217;t allow you to do this.
Such an expression is a syntax error in first-order logic.</p>
</section>
<section id="disjunction">
<h2><span class="section-number">3.4. </span>Disjunction<a class="headerlink" href="#disjunction" title="Permalink to this heading">&#61633;</a></h2>
<p>A LEAN DETAIL and IMPORTANT LANGUAGE DESIGN CONCEPT
A good language gives you good ways not to repeat yourself.
We can avoid having to repeatedly write &#8220;&#8704; (X Y : Prop),&#8221;
by creating a &#8220;section&#8221; in a Lean file, and declaring the
common variables once at the top. Lean then implicitly adds
a &#8220;&#8704; (X : Prop)&#8221; at the beginning of any expression that has
an X in it (and the same goes for Y and Z in this file).
I</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>
</div>
<p>In your mind, be sure to recognize that every one of the
following propositions now has an implicit &#8704; in front. The
or_intro_left definition that comes next, for example, means
def or_intro_left : Prop := &#8704; (X Y : Prop), X &#8594; X &#8744; Y.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">or_intro_left</span> <span class="o">:</span> <span class="kt">Prop</span>    <span class="o">:=</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="bp">&#8744;</span> <span class="n">Y</span>
<span class="kd">def</span> <span class="n">or_intro_right</span> <span class="o">:</span> <span class="kt">Prop</span>   <span class="o">:=</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="bp">&#8744;</span> <span class="n">Y</span>
<span class="kd">def</span> <span class="n">or_elim</span> <span class="o">:</span> <span class="kt">Prop</span>          <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8744;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">Z</span>
</pre></div>
</div>
<p>Lean, and other languages like it, also allow you to drop
explicit type judgments when they can be inferred from the
context. In the rest of this file, we also drop the &#8220;: Prop&#8221;
explicit type judgments because Lean can figure our from the
values that follow the :=&#8217;s that type types of the variables
here just have to be Prop.
Quiz questions.</p>
<p>Suppose you know that (X &#8594; Z) and (Y &#8594; Z) are true and you
want to prove Z. To be able to prove Z it will <em>suffice</em> to
prove ______; for then you will need only to apply the ______
rule to deduce that Z is true.</p>
<p>Suppose you know that (X &#8594; Z), (Y &#8594; Z), and Z are all true.
Is it necessarily that case that (X &#8744; Y) is also true? Defend
you answer.</p>
<p>Suppose it&#8217;s raining OR the sprinkler is running, and that in
either case the grass is wet. Is the grass wet? How would you
prove it?</p>
</section>
<section id="biimplication">
<h2><span class="section-number">3.5. </span>Biimplication<a class="headerlink" href="#biimplication" title="Permalink to this heading">&#61633;</a></h2>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">iff_intro</span>         <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="bp">&#8596;</span> <span class="n">Y</span>
</pre></div>
</div>
<p>You can read this rule both forward (left to right) and
backwards. Reading forwards, it says that if you have a
proof (or know the truth) of X &#8594; Y, and you have a proof
(or know the truth) of Y &#8594; X, then you can derive of a proof
(deduce the truth) of X &#8596; Y.</p>
<p>The more important direction in practice is to read it
from right to left. What it says in this reading is that
if you want to prove X &#8596; Y, then it will suffice to have
two &#8220;smaller&#8221; proofs: one of X &#8594; Y and one of Y &#8594; X.</p>
<p>From now on, whenever you&#8217;re asked to prove equivalence
of two propositions, X and Y, you&#8217;ll thus start by saying,
&#8220;It will suffice to prove the implication in each direction.&#8221;
Then you end up with two smaller goals to prove, one in
each direction. So, &#8220;We first consider X &#8594; Y.&#8221; Then give
a proof of it. Then, &#8220;Next we consider Y &#8594; X.&#8221; Then give
a proof of it. And finally, &#8220;Having proven the implication
in each direction (by application of the rule of &#8596; intro)
we&#8217;ve completed our proof. QED.&#8221;</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">iff_elim_left</span>     <span class="o">:=</span> <span class="n">X</span> <span class="bp">&#8596;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">iff_elim_right</span>    <span class="o">:=</span> <span class="n">X</span> <span class="bp">&#8596;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span>
</pre></div>
</div>
<p>The elimination rules are also easy. Given X &#8596; Y, you can
immediately deduce X &#8594; Y and Y &#8594; X.</p>
</section>
<section id="generalization">
<h2><span class="section-number">3.6. </span>Generalization<a class="headerlink" href="#generalization" title="Permalink to this heading">&#61633;</a></h2>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>

<span class="kd">def</span> <span class="n">arrow_all_equiv</span>   <span class="o">:=</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span>
</pre></div>
</div>
<p>To prove either (&#8704; (x : X), Y) or (X &#8594; Y), you first assume
that you&#8217;re given an arbitrary but specific proof of X, and
in that context, you show that you can derive a proof (thus
deducing the truth) of Y. It&#8217;s exactly the same reasoning in
each case. This is the <em>introduction</em> rule for &#8704; and &#8594;.
In fact, in constructive logic, X &#8594; Y is simply a notation
<em>defined</em> as &#8704; (x : X), Y. What each of these propositions
states in constructive logic is that &#8220;From <em>any</em> proof, x,
of X, we can derive a proof of Y.&#8221; In fact, in Lean, these
propositions are not only equivalent but equal.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span>          <span class="c1">-- Lean confirms this is a proposition</span>
<span class="k">#check</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">Y</span>   <span class="c1">-- Lean understands this to say X &#8594; Y!</span>
</pre></div>
</div>
<p>OPTIONAL
As an aside, here&#8217;s a proof that these propositions are
actually equal. This proof uses an inference rule, rfl, for
equality that we&#8217;ve not yet studied. Don&#8217;t worry about the
&#8220;rfl&#8221; for now, but trust that we&#8217;re giving a correct proof
of the equality of these two propositions in Lean</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">all_imp_equal</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>The reason it&#8217;s super-helpful to know these propositions
are equivalent is that it tells you that you can <em>use</em> a
proof of a &#8704; proposition or of a &#8594; proposition in exactly
the same way. So let&#8217;s turn to the <em>elimination</em> rules for
&#8594; and &#8704;.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arrow_elim</span>        <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span>        <span class="bp">&#8594;</span> <span class="n">X</span>   <span class="bp">&#8594;</span> <span class="n">Y</span>
<span class="kd">def</span> <span class="n">all_elim</span>          <span class="o">:=</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">),</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">X</span>   <span class="bp">&#8594;</span> <span class="n">Y</span>
</pre></div>
</div>
<p>The idea underlying these rules date to ancient times.
They both say &#8220;if from the truth or a proof of X you
can derive a proof or the truth of Y, and if you also
have a proof, or know the truth, of X, then you can (in
constructive logic) derive a proof of Y (or deduce the
truth of Y.&#8221;</p>
<p>Here&#8217;s an example. What we want to say in logic is
that if every ball is blue and b is some specific
ball then b is blue. The elimination rule for &#8704; and
&#8594; applies a generalization to a specific instance to
deduce that the generalized statement specialized to
a particular instance is true.</p>
<p>Note: In this example, Y is a proposition obtained by
plugging &#8220;x&#8221; into a one-argument predicate. So suppose
(&#8704; (x : X), Y) is read as &#8220;for any Ball x, x is blue.&#8221;
Here X is &#8220;Ball;&#8221; x is an arbitrary but specific Ball;
and Y is read as &#8220;x is blue.&#8221;</p>
<p>Now suppose that, in this context, you&#8217;re given a
<em>particular</em> ball, (b : X). What the overall rules
says is that you now conclude that &#8220;b is blue.&#8221;</p>
<p>The elimination rule works by <em>applying</em> a proof of
a universal generalization (showing that something
is true of <em>every</em> object of a particular kind) to
a <em>specific</em> object of that kind, to deduce that the
generalized statement is also true of that specific
object.</p>
<p>If every ball is blue, and if b is a ball, then b
must be blue. Another way to say it that makes a
bit more sense for the (X &#8594; Y) notation is that
&#8220;if being any ball, x, implies that x is blue, and
if b is some particular ball, then b is blue.
As an example, consider a predicate, (isBlue _), where you can fill
in the blank/argument with any Ball-type object. If b is a specific
Ball-type object, then (isBlue b) is a proposition, representing the
English-language claim that b is blue. Here&#8217;s how we represent this
predicate in Lean.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variable</span> <span class="n">Ball</span> <span class="o">:</span> <span class="kt">Type</span>            <span class="c1">-- Ball is a type of object</span>
<span class="kd">variable</span> <span class="n">isBlue</span> <span class="o">:</span> <span class="n">Ball</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span>
</pre></div>
</div>
<p>First we Ball to be the name of a type of object (like int or
bool). Then we define isBlue to be a construct (think function!)
that when given any object of type Ball as an argument yields a
proposition. To see how this works, suppose we have some specific
balls, b1 and b2.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="o">(</span><span class="n">b1</span> <span class="n">b2</span> <span class="o">:</span> <span class="n">Ball</span><span class="o">)</span>
</pre></div>
</div>
<p>Now let&#8217;s use isBlue to make some propositions!</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">isBlue</span>                               <span class="c1">-- a predicate</span>
<span class="k">#check</span> <span class="n">isBlue</span> <span class="n">b1</span>                            <span class="c1">-- a proposition about b1</span>
<span class="k">#check</span> <span class="n">isBlue</span> <span class="n">b2</span>                            <span class="c1">-- a proposition about b2</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Ball</span><span class="o">),</span> <span class="n">isBlue</span> <span class="n">x</span><span class="o">)</span>             <span class="c1">-- generalization</span>
<span class="kd">variable</span> <span class="n">all_balls_blue</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8704;</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Ball</span><span class="o">),</span> <span class="n">isBlue</span> <span class="n">x</span><span class="o">)</span>   <span class="c1">-- proof of it</span>
<span class="k">#check</span> <span class="n">all_balls_blue</span> <span class="n">b1</span>                    <span class="c1">-- proof b1 is blue</span>
<span class="k">#check</span> <span class="n">all_balls_blue</span> <span class="n">b2</span>                    <span class="c1">-- proof b2 is blue</span>
</pre></div>
</div>
<p>Here&#8217;s an English-language version.</p>
<p>Suppose b1 and b2 are objects of some type, Ball, and that isBlue
is one-place predicate taking any Ball, b, as an argument, and that
reduces to a proposition, denoted (isBlue b), that we understand as
asserting that the particular ball, b, is blue. Next (295), we take
all_balls_blue as a proof that all balls are blue. Finally (296 and
297), we see that we can can use this proof/truth by <em>applying</em> it
to any particular ball, b, to obtain a proof/truth that b is blue.</p>
<p>For any type S, given any X: (&#8704; s : S), T and any s : S, the &#8704;
and &#8594; elimination rule(s) say that you can derive a value/proof of
type T; moreover this operation is basically done by <em>applying</em> ,
viewed as a function from parameter value to proposition, to the
actual parameter, s (in Lean denoted as (X s)), to obtain a value
(proof) of (type) T. Modus ponens is like function application. In
constructive logic, a proof of the &#8704; proposition <em>is</em> a function.
Here you begin to see how profound is that proofs in constructive
logic tell you not only that a proposition is true but why. Here a
proof of X &#8594; Y or of &#8704; (x : X), Y, is a program that when given any
value/proof of X as an argument returns a value/proof of Y. If you
can produce a function that turns any proof of X into a proof of Y,
then you&#8217;ve shown that whenever X is true, so is Y; and that&#8217;s just
what X &#8594; Y is meant to say (similarly for &#8704; (x : X), Y).
Walk-away message: Applying a proof/truth of a universal
generalization to a specific object yields a proof of the
generalization <em>specialized</em> to that particular object. That
is in the higher-order predicate logic of Lean.</p>
<p>Finally, let&#8217;s compare our elimination rule, in the higher-order
predicate logic of Lean, with its first-order logic counterpart.</p>
<p>There are two big differences, first, in first-order logic, you
have to present the rule outside of the logic: you can&#8217;t write
rules like this, &#8704; (X Y : Prop), X &#8594; Y &#8594; (X &#8743; Y), in first-order
logic because in first order logic you can&#8217;t quantify over types,
propositions, predicates, functions. Here we do just this with the
&#8220;&#8704; (X Y : Prop).&#8221; By contrast, in the higher-order logic of Lean,
we can represent the rules of first-order logic with no problem:
e.g., &#8220;&#8704; (X Y : Prop), X &#8594; Y &#8594; (X &#8743; Y).&#8221;</p>
<p>Second, as we&#8217;ve discussed, using Lean&#8217;s higher-order logic, you
can think of a proof of &#8220;&#8704; (X Y : Prop), X &#8594; Y &#8594; (X &#8743; Y)&#8221; as a
function. Each variable bound by a &#8704; and each implication premise
is an argument, with the type of the return value at the end of
the line. So, here, a proof of this proposition can be taken as
a function that takes two propositions, X and Y as arguments, then
a proof (value) of (type) X, then a proof (value) of type Y, and
that finally returns a proof (value) X &#8743; Y. Whereas the proof of
&#8704; (X Y : Prop), X &#8594; Y &#8594; (X &#8743; Y) is a function the returned proof
of (X &#8743; Y) is a pair-like data structure. Proofs in constructive
logic are <em>computational</em>, and you can even compute with them, as
you do when you <em>apply</em> a proof of a certain kind to an argument
to obtain a resulting proof/value.
Quiz questions:</p>
<p>First-order logic. I know that every natural number is
beautiful (&#8704; n, NaturalNumber(n) &#8594; Beautiful(n) : true),
and I want to prove (7 is beautiful : true). Prove it.
Name the inference rule and identify the arguments you
give it to prove it.</p>
<p>Constructive logic. Suppose I have a proof, pf, that every
natural number is beautiful (&#8704; (n : &#8469;), beautiful n), and I
need a proof that 7 is beautiful. How can I get the proof
I need? Answer in both English and with a Lean expression.</p>
<p>Formalize this story: All people are mortal, and Plato
is a person, therefore Plato is Mortal.
Quick exercise. Give a proof of this (in English, and
give it a try in Lean as well.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">arrow_trans</span>       <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="true-and-false">
<h2><span class="section-number">3.7. </span>True and False<a class="headerlink" href="#true-and-false" title="Permalink to this heading">&#61633;</a></h2>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>
</div>
<p>In propositional logic, the literal expressions, true
and false, are part of the syntax of the logic, with
obvious interpretations. The &#8220;true&#8221; expression always
evaluates to Boolean true, and the &#8220;false&#8221; expression
to Boolean false. We could thus write expressions such
as (X &#8744; false) and (X &#8743; true).</p>
<p>In predicate logic we have the same concepts exactly.
In first order predicate logic, true is a proposition
that is invariably judged to be true, and false is a
proposition that is invariable false.</p>
<p>In the higher-order predicate logic defined in Lean,
true and false are also propositions, as we can see
with the following checks and an example.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">true</span>
<span class="k">#check</span> <span class="n">false</span>
<span class="k">#check</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">P</span> <span class="bp">&#8744;</span> <span class="n">true</span>
</pre></div>
</div>
<p>As with all of the basic connectives and quantifiers,
the <em>meanings</em> of these terms are established by their
inference rules. We address the rules for each one now.
We want &#8220;true&#8221; to be a proposition that is always true.
In constructive logic, that means there&#8217;s always a proof
of it. Indeed, in Lean, that proof is called true.intro.
The way to prove that &#8220;true&#8221; is true is by giving this
proof as evidence.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">true_is_true</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span> <span class="n">true.intro</span>
</pre></div>
</div>
<p>In other words, there&#8217;s always a trivial proof lying
around to prove that the proposition, &#8220;true,&#8221; is true.
Let&#8217;s decode that theorem:
- &#8220;theorem&#8221; says we&#8217;re about to prove a proposition
- the proposition in this case is &#8220;true&#8221;
- and the proof is true.intro
The Lean prover accepts this proof as correct. It is.
Simply put, true.intro is the introduction rule for the
proposition, &#8220;true,&#8221; in Lean.
What about the elimination rule for true? Well, having
a proof of true gives you essentially zero information,
so there&#8217;s nothing useful you can really do with a proof
of true. Thus there is no elimination rule for true.
Next, we want the inference rules for the proposition,
&#8220;false&#8221; to capture two ideas. First, the proposition
&#8220;false&#8221; must always be logically false. In first-order
logic, that&#8217;s all there is to it. In the constructive
logic of Lean, the proposition &#8220;false,&#8221; is logically
false <em>because it is defined to be a proposition that
has no proofs.</em> Because it has no proofs, there is no
introduction rule for &#8220;false.&#8221; If there were, then we
would be able to use it to construct a proof of false,
which can&#8217;t exist.&#8221; There is thus <em>no possible way</em> to
complete the following definition.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">a_proof_of_false</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="n">_</span>   <span class="c1">-- no can do!</span>
</pre></div>
</div>
<p>Now we get to the most interesting and important rule:
false elimination, or the elimination rule for &#8220;false.&#8221;</p>
<p>As you recall, in propositional logic, false &#8594; X is
always true, no matter whether X is true or false.
So, false &#8594; false is true, and false &#8594; true is true.</p>
<p>Now suppose P is any proposition in first-order logic.
The elimination rule for &#8220;false&#8221; is false &#8866; P. In
other words, if you assume or have somehow proven
false (which is possible from a false premise), then
you can deduce that anything at all is true: including
P, no matter what proposition it is, even if it&#8217;s a
false proposition. As they say, &#8220;from false anything
follows,&#8221; or, in Latin, &#8220;ex falso quodlibet.&#8221;</p>
<p>This principle makes good sense, because if false is
true (the premise), then even if a proposition, P, is
false, false is true, so P is true (too)!
A little practice. Which of the following propositions
in predicate logic is true?</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">p1</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">false</span> <span class="bp">&#8594;</span> <span class="n">false</span>
<span class="kd">def</span> <span class="n">p2</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">false</span> <span class="bp">&#8594;</span> <span class="n">true</span>
<span class="kd">def</span> <span class="n">p3</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span> <span class="bp">&#8594;</span> <span class="n">true</span>
<span class="kd">def</span> <span class="n">p4</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">true</span> <span class="bp">&#8594;</span> <span class="n">false</span>
<span class="kd">def</span> <span class="n">p5</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">false</span> <span class="bp">&#8594;</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">3</span>
<span class="kd">def</span> <span class="n">p6</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">false</span> <span class="bp">&#8594;</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span>
<span class="kd">def</span> <span class="n">p7</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">true</span> <span class="bp">&#8594;</span> <span class="n">P</span>
<span class="kd">def</span> <span class="n">p8</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="n">false</span> <span class="bp">&#8594;</span> <span class="n">P</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">p8_is_true</span> <span class="o">:</span> <span class="n">p8</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p8</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">f</span><span class="o">,</span>
<span class="n">apply</span> <span class="n">false.elim</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>For each proposition, state whether it&#8217;s true or false
then give a proof of it (in English). Here are some formal
proofs to help.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- def p1 : Prop := false &#8594; false</span>
<span class="kd">theorem</span> <span class="n">x</span> <span class="o">:</span> <span class="n">p1</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">p1</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">f</span> <span class="o">:</span> <span class="n">false</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="c1">-- false &#8594; true</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">p2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">unfold</span> <span class="n">p2</span><span class="o">,</span>
  <span class="k">assume</span> <span class="n">f</span><span class="o">,</span>           <span class="c1">-- move premise into context</span>
  <span class="c1">--exact true.intro,   -- don&#39;t have to use assumption</span>
  <span class="c1">-- apply false.elim f,</span>
  <span class="n">contradiction</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p3</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p3</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">t</span><span class="o">,</span>
<span class="n">exact</span> <span class="n">t</span><span class="o">,</span>    <span class="c1">-- exact true.intro also works</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p4</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p4</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">t</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p5</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p5</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">f</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p6</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p6</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">f</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
<span class="c1">-- exact rfl,</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>What? The cases tactic applies the elimination rule to
an assumed or derived proof of false. For each of the
ways that the proof, f, could have been constructed,
you have a case to consider; but there are no ways a
proof of false can be constructed so you have no cases
to consider, so the proof is done! This is another way
to understand how/why false elimination works in the
constructive logic of Lean and other similar tools.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p7</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p7</span><span class="o">,</span>
<span class="n">intro</span> <span class="n">P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">t</span><span class="o">,</span>
<span class="c1">-- stuck</span>
<span class="kd">end</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">p8</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">unfold</span> <span class="n">p8</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">P</span> <span class="n">f</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">f</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
</section>
<section id="negation">
<h2><span class="section-number">3.8. </span>Negation<a class="headerlink" href="#negation" title="Permalink to this heading">&#61633;</a></h2>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>
</div>
<p>With an understanding of &#8220;false&#8221; and its elimination rule, we
can now talk about the inference rules for negation.
Recall that if P is any proposition, then (not P), generally
written as &#172;P, is also a proposition. when is &#172;P true? It&#8217;s
true in first-order logic if P is false. It&#8217;s also true in
constructive logic when P is false, which is to say, <em>when
there are no proofs of P</em>.</p>
<p>Now here&#8217;s the slightly tricky way that we show that there can
be no proof of P. We show (P &#8594; false). What this proposition
says is that &#8220;If there is a proof of P, then from it we can
derive an impossibility, so there must be no proof of P. This
is the rule of false introduction: prove P &#8594; false, conclude
&#172;P. &#172;P is true iff P &#8594; false. Indeed, in our logic we simply
<em>define</em> &#172;P to mean P &#8594; false.
Right click on not and click &#8220;go to definition&#8221; to see the
definition of (not P) and the definition of &#172;P as a notation
for (not P).</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">not</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span> <span class="n">pred_logic</span>
<span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">false</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>   <span class="c1">-- assume 0 = 1; this can&#39;t happen, of course</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">,</span>    <span class="c1">-- there&#39;s no way to prove 0 = 1, so NOT (0=1)</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Here&#8217;s exactly the same proposition but using &#172; notation</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="mi">0</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">,</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Remember!  0 &#8800; 1 means &#172;(0 = 1) means 0 = 1 &#8594; false. You
must remember that when you want to prove &#172;P, that means
you need to prove P &#8594; false: that a proof of P is an
impossibility.  Remember this, because it tells you how
to prove &#172;P. To show it, assume the premise, 0 = 1, then
show that this assumption gives rise to an impossibility
(a proof of false).</p>
<section id="proof-by-negation">
<h3><span class="section-number">3.8.1. </span>Proof by Negation<a class="headerlink" href="#proof-by-negation" title="Permalink to this heading">&#61633;</a></h3>
<p>What we&#8217;ve now seen is a crucial &#8220;proof strategy&#8221; often
called &#8220;proof by negation.&#8221;&#8221; To show &#172;P (that P is false),
we prove P &#8594; false. How? assume P is true and show that from
this assumption you can derive a contradiction, something
that cannot be, such as proof of false.
HW #3 Exercise: state and prove the rule (the &#8220;theorem&#8221;)
of &#8220;no contradiction:&#8221; first in English and then in the
predicate logic of Lean. Or if you prefer, work it out
in Lean and the write it in English. The formal statement
of the proposition is in the partially completed theorem
below.
English. Prove &#172;(X &#8743; &#172;X), where X is any proposition.
This theorem states that it cannot be the case that
both X and &#172;X are true.</p>
<p>Proof by negation: Assume that (X &#8743; &#172;X) is true. By
use of and elimination deduce X and &#172;X separately.
But this is a contradiction, so the assumption must
have been false. Therefore &#172;(X &#8743; &#172;X) is proved. QED.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">no_contradiction</span> <span class="o">:</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">X</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>           <span class="c1">-- where h proves (X &#8743; &#172;X)</span>
<span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">x</span> <span class="n">nx</span><span class="o">,</span>  <span class="c1">-- applies and elimination</span>
<span class="n">exact</span> <span class="o">(</span><span class="n">nx</span> <span class="n">x</span><span class="o">),</span>       <span class="c1">-- (nx x) is a proof of false</span>
<span class="kd">end</span>
</pre></div>
</div>
</section>
<section id="proof-by-contradiction">
<h3><span class="section-number">3.8.2. </span>Proof by Contradiction<a class="headerlink" href="#proof-by-contradiction" title="Permalink to this heading">&#61633;</a></h3>
<p>First, recall that in proof by negation, we prove &#172;P by
assuming that P is true, deriving an impossibility, and
then concluding &#172;P.</p>
<p>Proof by contradiction is just a tad more complicated. In
this proof strategy we prove P (rather than &#172;P) by assuming
&#172;P (rather than P) and showing that <em>this</em> assumption leads
to an impossibility, a contradiction. What that proves is
that &#172;P must be false, which is to say, &#172;&#172;P. Finally, from
there, we conclude P using <em>negation elimination</em>. This rule
is simply this (recall that we introduced X as an arbitrary
propostion above):</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">neg_elim</span>          <span class="o">:=</span> <span class="bp">&#172;&#172;</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">X</span>
</pre></div>
</div>
<p>As a silly but simple example, let&#8217;s prove that 0 = 0 using
the strategy of proof by contradiction.</p>
<p>Goal: Prove 0 = 0.
Proof (by contradiction). Assume h: &#172;(0 = 0). Recall that
this means h is a proof of (0 = 0) &#8594; false. But 0 = 0 is
true, so there is a proof of it, let&#8217;s call it pf. Now we
simply apply h to pf (arrow elimination) to derive a proof
of false. By &#172; introduction, this proves &#172;&#172;(0 = 1). Finally
we apply negation elimination to deduce that (0 = 1) is true.
In Lean, &#8220;by_contradiction&#8221; is the name of the negation
elimination rule. Because it relies on a non-constructive
assumption, it&#8217;s tucked away in a module called classical.
We can use it by referring to classical.by_contradiction.
The &#64; sign here is a detail you can ignore for now. It
just tells Lean to report the rule as its&#8217; written where
it&#8217;s defined.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">classical.by_contradiction</span>
<span class="c1">-- &#8704; {p : Prop}, (&#172;p &#8594; false) &#8594; p</span>
<span class="c1">-- in other words, &#8704; (P : Prop), &#172;(&#172;P) &#8594; P</span>
<span class="c1">-- Proof by contradiction is application of &#172; elimination!</span>
</pre></div>
</div>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">apply</span> <span class="n">classical.by_contradiction</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">h</span><span class="o">,</span>               <span class="c1">-- assume &#172; 0 = 0</span>
<span class="k">let</span> <span class="n">k</span> <span class="o">:=</span> <span class="n">eq.refl</span> <span class="mi">0</span><span class="o">,</span>     <span class="c1">-- but we can have k a proof of 0 = 0</span>
<span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="n">h</span> <span class="n">k</span><span class="o">,</span>           <span class="c1">-- that&#39;s an impossibility (here a proof of false)</span>
<span class="n">apply</span> <span class="n">false.elim</span> <span class="n">f</span><span class="o">,</span>     <span class="c1">-- ex falso quodlibet! QED.</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>We can&#8217;t prove negation elimination to be valid in constructive logic!</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="bp">&#172;&#172;</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">nnp</span><span class="o">,</span>
<span class="c1">-- stuck!!!</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>But as a real wonder, it turns out that if you assume
that the law of the excluded middle is valid, then that
is sufficient to make negation elimination valid again.
The axiom of the excluded middle says that any and
every proposition has a Boolean truth value: it is
either true, or false, and there&#8217;s nothing else it
could be.</p>
<p>In constructive logic, by contrast, if you don&#8217;t
have either a proof of P or of &#172;P, then you can&#8217;t
build a proof of P &#8744; &#172;P. By contrast, in &#8220;classical&#8221;
logic for any proposition, P, you have have a proof
of P &#8744; &#172;P &#8220;for free,&#8221; just by applying em to P.
In Lean, classical.em is a proof of &#8704; P, P &#8744; &#172;P.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">classical.em</span>
<span class="c1">-- em : &#8704; (p : Prop), p &#8744; &#172;p</span>
</pre></div>
</div>
<p>The crucial point about the law of the excluded
middle is that (because it&#8217;s a universal generalization)
you can <em>apply</em> it to any proposition, P, to get a &#8220;free&#8221;
proof of P &#8744; &#172;P; <em>and on that you can do case analysis,</em>
with just two cases: in one case P is true because you
have a proof of it; and in the other case you have a
proof of &#172;P. As long as you can show that your goal
follows &#8220;in either case&#8221;, you&#8217;ve proved your goal.
So let&#8217;s see exactly how accepting the law of the
excluded middle (em) suffices to prove the validity
of negation elimination, &#172;&#172;P &#8594; P. Remember that proof
by contradiction is used to prove P by assuming &#172;P
and showing that that yeilds an impossibility, thus
proving &#172;(&#172;P), from which, by negation elimination
you can deduce P, which was the original goal.</p>
<p>Here&#8217;s the final secret. Read negation elimination
rule backwards. What is says is that if you want
to prove P, it will <em>suffice</em> to prove &#172;&#172;P, for if
you do that, you just apply negation elimination
to prove P.</p>
<p>In other words. if your goal is P, and you apply
negation elimination, your new goal is to prove
&#172;&#172;P. Now recall that &#172;&#172;P just means (&#172;P) &#8594; false.
To prove this, assume &#172;P! And then show that this
assumption leads to a situation that can&#8217;t happen,
and where therefore there is nothing else to be
considered. False elimination really means that
you can ignore the consequences of situations
that can never even happen in the first place.
Now we can show that if we accept em as an axiom,
then negation elimination is valid</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span>   <span class="c1">-- for any proposition P</span>
    <span class="o">(</span><span class="n">P</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">P</span><span class="o">)</span> <span class="bp">&#8594;</span>    <span class="c1">-- ***if we assume em is valid**</span>
    <span class="o">(</span><span class="bp">&#172;&#172;</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span><span class="o">)</span>     <span class="c1">-- ***then neg elim is valid***</span>
  <span class="o">:=</span>
<span class="kd">begin</span>
<span class="k">assume</span> <span class="n">P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">em_P</span><span class="o">,</span>
<span class="k">assume</span> <span class="n">nnp</span><span class="o">,</span>
<span class="n">cases</span> <span class="n">em_P</span> <span class="k">with</span> <span class="n">p</span> <span class="n">np</span><span class="o">,</span>
<span class="c1">-- case P</span>
<span class="n">exact</span> <span class="n">p</span><span class="o">,</span>
<span class="c1">-- &quot;assumption&quot; also works heew</span>
<span class="c1">-- case &#172;P</span>
<span class="n">apply</span> <span class="n">false.elim</span> <span class="o">(</span><span class="n">nnp</span> <span class="n">np</span><span class="o">)</span>
<span class="c1">-- &quot;contradiction&quot; also works here</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Exercises: Prove that the following propositions are theorems
(that they have proofs). Express your proofs in English. For
extra credit, provide formal proofs in Lean. Hint: Working out
the proofs in Lean can be a big help to expressing them in
English.</p>
<p>Prove that these propositions are</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">contrapostitive</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="bp">&#172;</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">X</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">demorgan1</span>         <span class="o">:=</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">X</span> <span class="bp">&#8744;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">X</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span><span class="n">Y</span>
<span class="kd">def</span> <span class="n">demorgan2</span>         <span class="o">:=</span> <span class="bp">&#172;</span><span class="o">(</span><span class="n">X</span> <span class="bp">&#8743;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span><span class="n">X</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">Y</span>
</pre></div>
</div>
<p>EXTRA MATERIAL/CREDIT</p>
<p>It also turns out that if you assume that negation
elimination, (&#172;&#172;P &#8594; P) is valid, then you can prove
that excluded middle is, too: (&#8704; (P : Prop), P &#8744; &#172;P).</p>
<p>Indeed, in our logic, the two axioms are equivalent.
Here&#8217;s a formal statement of that proposition, with
an extra credit opportunity for you to prove it in
both directions.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">theorem</span> <span class="n">em_equiv_pbc</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">),</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8744;</span> <span class="bp">&#172;</span><span class="n">P</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="o">(</span><span class="bp">&#172;&#172;</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
<span class="n">_</span>         <span class="c1">-- challenge problem, on your own</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Assume P is a proposition then see that you can
&#8220;apply iff.intro _ _&#8221;) to construct a proof for
your overall goal. You&#8217;re done, with you nidge:
you &#8220;borrowed&#8221; proofsfrom the future and now you
have to pay them back. You&#8217;re thus left with two
remaining sub-goals. In this way, you provide a
complete proof but with some &#8220;blanks&#8221; that still
need to be filled in. Lean typechecks such proofs
with holes and knows the types of proofs/values
needed for each one. These are the subgoals that
remain.</p>
<p>This is the vitally important computer science
&#8220;strategy&#8221; of top-down, structured, type-guided
decomposition of a problem. You apply to a hard
problem by producing a complete solution pending
completion of remaining holes; then you apply
the same strategy to fill each hole; until you
fill holes with values that themselfes have no
remaining holes! Then you&#8217;re done.</p>
<p>What&#8217;s saddening, always a little at least, is
when you&#8217;ve expanded a whole tree of holes and
then filled in many only to find that you&#8217;re
stuck. Yeah, that can make it hard to <em>find</em>
proofs. You must back up, undo some assumptions,
and then move forward ahead. This is called a
back-tracking search strategy. Mathematicians
<em>search</em> for proofs. Those who are especially
goodhave uncanny senses for unpromising paths
to avoid.</p>
<p>Even so, the complete formalization of a proof
of the Four-Color Theorem took G.Gonthier six
years to complete at Microsoft Research. Along
the way he had to build a significant formal
theory of a lot of the underlying mathematics,
e.g., in such areas as topology.</p>
<p>Main take-away message: when a proof of Q is
needed, we can often apply an inference rule
or theorem, to assumed arguments, to constrct
a proof of Q <em>even if we don&#8217;t have values for
the arguments yet</em>. In this way, we build a
complete solution &#8220;modulo&#8221; remaining &#8220;proof
obligations,&#8221; or &#8220;subgoals.&#8221; This approach
is top-down, structured (read hierarchical),
type-guided decomposition. It reduces a hard
problem to a complete solution in one step,
pending the satisfaction of zero or more
remaining subproblems. If it&#8217;s zero, QED; if
not, keep going, consider backtracking, etc.</p>
</section>
</section>
<section id="predicates">
<h2><span class="section-number">3.9. </span>Predicates<a class="headerlink" href="#predicates" title="Permalink to this heading">&#61633;</a></h2>
<p>OVERVIEW</p>
<p>To readily understand the introduction rule and the
elimination rule for proofs of existential propositions
(starting with &#8707;), we first need a review of predicates.
Predicate in turn are thought of as functions from the
arguments to propositions &#8220;about&#8221; those arguments. So
we also discuss function definitions, more generally,
and how we can specify them in various ways in Lean.
Finally we come back to the inference rules for &#8707;.
-/</p>
<p>/- PREDICATES
KS: THERE&#8217;S MORE HERE. FIX SOURCE FILE.</p>
<p>A predicate is a proposition with one or more parameters.
A proposition is a predicate with no remaining parameters!</p>
<p>You can think of a predicate it as a function that takes
one or more arguments and that reduces to a proposition
<em>about those particular values</em>.</p>
<p>Here, for example, we define a predicate, called isEven,
that takes a natural number, n, as an argument and that
reduces to (&#8220;returns&#8221;) the proposition, n % 2 = 0, <em>for
that particular n</em>.
-/</p>
<p>def isEven : &#8469; &#8594; Prop :=
begin
assume n,
exact (n%2 = 0)
end</p>
<p>/-
In fact, in Lean and similar logical programming systems,
a predicate <em>is</em> a function, and can thus be applied to an
argument of the specified type.
-/</p>
<p>#reduce isEven 0      &#8211; 0 = 0
#reduce isEven 1      &#8211; 1 = 0
#reduce isEven 2      &#8211; 0 = 0
#reduce isEven 3      &#8211; 1 = 0</p>
<p>/-
Note that the n%2 expression is evaluated automatically.
-/</p>
<p>/-
We will say that one or more values &#8220;satisfy&#8221; a predicate
when the corresponding proposition is true. In constructive
logic, that means when there&#8217;s a proof of that proposition.
-/</p>
<p>example : isEven 0 :=
begin
simp [isEven],  &#8211; new tactic: simplify by def&#8217;n of isEven
exact rfl,      &#8211; forces reduction, tests equality
&#8211; Yay! 0 is even
end</p>
<p>&#8211; The rfl tactic does some simplification automatically
example : isEven 0 :=
begin
exact rfl,      &#8211; forces reduction, tests equality
&#8211; Yay! 0 is even
end</p>
<p>example : isEven 1 :=
begin
exact rfl,      &#8211; there&#8217;s no proof of 1=0
&#8211; Ooooh noooo, 1 is not even
end</p>
<p>&#8211; In fact we can prove the negation
example : &#172;isEven 1 :=
begin
assume h,
simp [isEven] at h, &#8211; more tactic fun (optional)
cases h,            &#8211; no proofs of h so done
&#8211; Yay! 1 is <em>not</em> even (proof by negation)
end</p>
<p>&#8211; Proof that 2 is even
example : isEven 2 :=
begin
exact rfl,
&#8211; Yay! 2 is even.
end</p>
<p>/-
A predicate expresses a <em>property</em> of the objects
it takes as arguments. Here the predicate expresses
the property of a natural number <em>being even</em> (or not).
Every natural number, n, that satisfies the predicate
(for which there&#8217;s a proof) has the property expressed
by isEven,  while every number lacks this property.</p>
<p>We speak of values that &#8220;satisfy&#8221; a predicate as
having the property that it expresses. Again, as an
example, evenness is a property of natural numbers.
Some have it, some don&#8217;t. Every n for which n%2=0
has it, and no other number does (in &#8469;).</p>
<p>A predicate can also be understood as specifying a
<em>set</em> of values: in this example, the set of all
even natural numbers: all those n where n % 2 = 0.
-/</p>
</section>
<section id="existence">
<h2><span class="section-number">3.10. </span>Existence<a class="headerlink" href="#existence" title="Permalink to this heading">&#61633;</a></h2>
<p>There are two inference rules for &#8707; propositions:
one introduction, one elimination. In Lean they are
called exists.intro and exists.elim. We will usually
use the cases tactic to apply the elimintion rule and
clean up the results. We generally apply the intro
rule directly.</p>
<p>MORE HERE. FIX SOURCE.</p>
</section>
<section id="fallacies">
<h2><span class="section-number">3.11. </span>Fallacies<a class="headerlink" href="#fallacies" title="Permalink to this heading">&#61633;</a></h2>
<p>Here are the logical fallacies we first met in propositional
logic, now presented in the richer context of constructive
logic. You might guess that it will be impossible to construct
proofs of these fallacies, and you would be correct.</p>
<p>FIX SOURCE FILE.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Prop</span>
<span class="kd">def</span> <span class="n">converse</span>          <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">deny_antecedent</span>   <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">Y</span>
<span class="kd">def</span> <span class="n">affirm_conclusion</span> <span class="o">:=</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">affirm_disjunct</span>   <span class="o">:=</span> <span class="n">X</span> <span class="bp">&#8744;</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span><span class="n">Y</span><span class="o">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="01_Functions_and_Applications.html" class="btn btn-neutral float-left" title="2. Functions and Applications" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>