<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. CS6501 Spring 2023 &mdash; CS6501 Spring 2023 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Formal Languages" href="01_Propositional_Logic_Syntax_Semantics.html" />
    <link rel="prev" title="A Predicate Logic" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CS6501 Spring 2023
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. CS6501 Spring 2023</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#to-think-abstractly">1.1. To Think Abstractly</a></li>
<li class="toctree-l2"><a class="reference internal" href="#welcome-overview">1.2. Welcome. Overview.</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-does-abstract-mean-here">1.2.1. What does <em>abstract</em> mean here?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-abstract-mathematics">1.2.2. Why <em>abstract</em> mathematics?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-the-point">1.2.3. What is the point?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#this-class">1.2.4. This class</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="01_Propositional_Logic_Syntax_Semantics.html">2. Formal Languages</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CS6501 Spring 2023</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>CS6501 Spring 2023</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/00_Introduction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cs6501-spring-2023">
<span id="introduction"></span><h1><span class="section-number">1. </span>CS6501 Spring 2023<a class="headerlink" href="#cs6501-spring-2023" title="Permalink to this heading">&#61633;</a></h1>
<section id="to-think-abstractly">
<h2><span class="section-number">1.1. </span>To Think Abstractly<a class="headerlink" href="#to-think-abstractly" title="Permalink to this heading">&#61633;</a></h2>
<p>To think abstractly, and certainly to perform scientific
reasoning effectively, we need languages in which we can
describe and reason about complex worlds. By a world we
mean a collection of various objects of interest, having
various properties of interest, and related to each other
in ways of interest. Formal mathematical logics provide
us with such languages.</p>
<p>Industrial programming languages are among such logics.
Logics of this kind have the property of being imperative:
they are used to specify <em>procedures</em> that update memories
and interact with worlds outside the logic (e.g., through
input/output (I/O) actions).</p>
<p>While the realm of practical programming languages&#8211;their
theory, design, implementation, and evolution&#8211;is vitally
important and deeply fascinating, it will not be the main
topic or aim of this course.</p>
<p>We will use the foundational theoretical framework used
in much research in programming languages, namely type
theory; but where it&#8217;s used in the programming languages
community to specify programming languages and to define
methods for reasoning about programs in such languages,
our aim is to understand how it&#8217;s used as a foundation
for the formalization of abstract mathematics.</p>
<p>The point of view driving this course is that in enough
domains to matter greatly, abstract mathematics is the
language of the field; and these are fields that we will
often want to program!</p>
<p>The idea of raising the abstraction level of programming
languages and programs is ages old. But these increases
in abstration are usually incremental and ad hoc, driven
by what can be computed efficiently at program compile or
run time.</p>
<p>Examples about. Dahl and Nygaard developed the concept
of objects (Simula 67). Simonyi introduced intentional
programming. Kiczales exhoted us to make the code look
like the design.</p>
<p>Our idea is different. we start with the observation
that Domains have already developed the
appropriate, often highly expressive, languages in which
to specify their worlds &#8211; states of affairs amongst given
objects and relations that they care about. For example,
the algebra of affine spaces is very well suited for the
description of key elements in basic classical robotics,
while descriptions of fundamental particles of physics
relies on the mathematics of tensor fields on topological
manifolds.</p>
<ul class="simple">
<li><p>formal languages</p></li>
<li><p>objects and their properties</p></li>
<li><p>imperative vs declarative languages</p></li>
<li><p>implementation vs specification</p></li>
<li><p>programming vs abstract mathematics</p></li>
<li><p>expressiveness vs tractability</p></li>
</ul>
</section>
<section id="welcome-overview">
<h2><span class="section-number">1.2. </span>Welcome. Overview.<a class="headerlink" href="#welcome-overview" title="Permalink to this heading">&#61633;</a></h2>
<p>This is a special topics course in software engineering. The idea
that we will explore is that we can now import ongoing advances
in the formalization of abstract mathematics (in type theory and
to a significant extent around the Lean prover and its mathematics
libraries) as new foundations for engineering software programs for
systems that inhabit domains that have such abstract mathematical
underpinnings. Such domains include physics, and thus also a broad
range of cyber-physical systems.</p>
<p>Along the way, you&#8217;ll learn formal logic and proof construction,
foundations of programming languages, functional programming, and
more. By the end you will know how to use some cutting-edge tools,
type theory and constructive logic proof assistants, to formalize
the abstract mathematics of important application domains.</p>
<section id="what-does-abstract-mean-here">
<h3><span class="section-number">1.2.1. </span>What does <em>abstract</em> mean here?<a class="headerlink" href="#what-does-abstract-mean-here" title="Permalink to this heading">&#61633;</a></h3>
<p>Here, the adjective, abstract, means <em>being coordinate-free</em>.
For the opposite of <em>abstract</em>, we&#8217;ll use <em>parametric</em>. The idea
is that a mathematical object, such as a vector, can be understood
simply as such, with no reference to coordinates; or that same abstract
vector can be represented concretely/parametrically as a struture of
parameter values expressed relative to some given frame of reference.</p>
</section>
<section id="why-abstract-mathematics">
<h3><span class="section-number">1.2.2. </span>Why <em>abstract</em> mathematics?<a class="headerlink" href="#why-abstract-mathematics" title="Permalink to this heading">&#61633;</a></h3>
<p>A premise of this class is that domain experts (e.g., in the
physics of terrestrial robotics, or of elemenary particles) speak,
model, analyze, and understand the operation of systems in the
abstract mathematical language of the domain, and very often not
in terms of ultimately arbitrarily selected frames of reference .</p>
<p>This is clear in physics where complex mathematical structures
such as tensor fields on topological manifolds are essential for
precise definitions of phenomena in particle physics.</p>
<p>Domain-specific abstract mathematics formalized in type theory
is what we see as an important language of the domain, to serve
as a basis for programming with static checking of abstractions,
and with parametric representations carried along as necessary.</p>
</section>
<section id="what-is-the-point">
<h3><span class="section-number">1.2.3. </span>What is the point?<a class="headerlink" href="#what-is-the-point" title="Permalink to this heading">&#61633;</a></h3>
<p>A remarkable feature of constructive logics as hosted by many
proof assistants is that they can compute. Computation is now
wholly integral to practical logical reasoning if only because
some proofs require systematic case analysis over very large
numbers of cases, given as the outputs of other computations.</p>
<p>This is is relevant because it suggests that fully formalizing
the fully developed mathematical language of the given domain,
we will be well on our way to having reference specifications
and with computable implementations.</p>
<p>Going even further, the most recent version of Lean is intended
as an efficient general-purpose programming language as well as
a proof assistant, compiling to C, and with workable language
interoperability interfaces.</p>
<p>In the future we expect to be able to statically type check and
foundationally verify &#8220;code&#8221; written in the abstract mathematics
of the domain and with very little custom coding needed also to
have corresponding verified implementations, even if only used as
test oracles for production code.</p>
<p>This is the of abstract specifictions from which concrete
implementations are derived. I will not say refined because
in practice most derivations are not refinements but rather
toyish models of semantically rich and complex computations
in the source domain.</p>
</section>
<section id="this-class">
<h3><span class="section-number">1.2.4. </span>This class<a class="headerlink" href="#this-class" title="Permalink to this heading">&#61633;</a></h3>
<p>The first major part of this class will teach you the fundamentals
of programming and reasoning in Lean 3. We will mainly use Lean 3,
nothwithstaning that Lean 4 is garnering real attention and effort.
Student might wish to explore Lean 4 as an optional class activity.</p>
<p>The second part of the class will focus on how to formalized abstract
mathematical structures in Lean, and how we might such capabilities
to  these advances in formalizing mathematics to help meet
the need for statically type checked specifications in the abstract
language of the domain, with corresponding parametric representations
carried along for computational possibly and oher purposes.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="A Predicate Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="01_Propositional_Logic_Syntax_Semantics.html" class="btn btn-neutral float-right" title="2. Formal Languages" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Kevin Sullivan.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>